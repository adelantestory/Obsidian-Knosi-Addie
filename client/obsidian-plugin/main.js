/*
Vault RAG Sync Plugin for Obsidian
*/

var p=Object.defineProperty;var y=Object.getOwnPropertyDescriptor;var f=Object.getOwnPropertyNames;var S=Object.prototype.hasOwnProperty;var m=(c,i)=>{for(var e in i)p(c,e,{get:i[e],enumerable:!0})},w=(c,i,e,t)=>{if(i&&typeof i=="object"||typeof i=="function")for(let s of f(i))!S.call(c,s)&&s!==e&&p(c,s,{get:()=>i[s],enumerable:!(t=y(i,s))||t.enumerable});return c};var v=c=>w(p({},"__esModule",{value:!0}),c);var $={};m($,{default:()=>u});module.exports=v($);var n=require("obsidian"),x={serverUrl:"http://localhost:48550",apiKey:"",autoSync:!0,syncOnStartup:!0,syncIntervalMinutes:1,supportedExtensions:[".md",".txt",".pdf",".html",".htm",".org",".rst",".png",".jpg",".jpeg",".gif",".webp"],excludePatterns:[".obsidian/",".trash/","Templates/"],verboseLogging:!1},u=class extends n.Plugin{constructor(){super(...arguments);this.syncInProgress=!1;this.pendingUploads=new Set;this.pendingDeletes=new Set;this.syncIntervalId=null}async onload(){await this.loadSettings(),this.statusBarItem=this.addStatusBarItem(),this.updateStatusBar("idle"),this.settings.autoSync&&(this.registerEvent(this.app.vault.on("create",e=>this.queueFileUpload(e))),this.registerEvent(this.app.vault.on("modify",e=>this.queueFileUpload(e))),this.registerEvent(this.app.vault.on("delete",e=>this.queueFileDelete(e))),this.registerEvent(this.app.vault.on("rename",(e,t)=>this.handleFileRename(e,t))),this.startSyncInterval()),this.addCommand({id:"sync-current-file",name:"Sync current file (immediate)",callback:()=>this.syncCurrentFile()}),this.addCommand({id:"sync-queue-now",name:"Process sync queue now",callback:()=>this.processQueue()}),this.addCommand({id:"sync-all-files",name:"Sync all files",callback:()=>this.syncAllFiles()}),this.addCommand({id:"check-server-status",name:"Check server status",callback:()=>this.checkServerStatus()}),this.addCommand({id:"view-queue",name:"View pending sync queue",callback:()=>this.viewQueue()}),this.addSettingTab(new g(this.app,this)),this.settings.syncOnStartup&&setTimeout(()=>this.syncAllFiles(),3e3),console.log("Knosi Sync plugin loaded")}onunload(){this.stopSyncInterval(),this.pendingUploads.clear(),this.pendingDeletes.clear(),console.log("Knosi Sync plugin unloaded")}async loadSettings(){this.settings=Object.assign({},x,await this.loadData())}async saveSettings(){await this.saveData(this.settings)}async saveSettingsAndRescan(e){await this.saveData(this.settings);let t=this.settings.supportedExtensions;JSON.stringify(e)!==JSON.stringify(t)&&this.rescanVaultForNewExtensions(e,t)}async saveSettingsAndRescanExclusions(e){await this.saveData(this.settings);let t=this.settings.excludePatterns;JSON.stringify(e)!==JSON.stringify(t)&&this.rescanVaultForNewExclusions(e,t)}rescanVaultForNewExtensions(e,t){let s=t.filter(r=>!e.includes(r));if(s.length===0)return;console.log(`Rescanning vault for new extensions: ${s.join(", ")}`),new n.Notice(`Rescanning vault for: ${s.join(", ")}`);let o=this.app.vault.getFiles(),a=0;for(let r of o){let l="."+r.extension.toLowerCase();s.includes(l)&&!this.isExcluded(r.path)&&(this.pendingUploads.add(r.path),a++)}a>0?(console.log(`Queued ${a} files for sync`),new n.Notice(`Queued ${a} files for sync`),this.updateStatusBar("pending")):new n.Notice("No new files found to sync")}rescanVaultForNewExclusions(e,t){let s=t.filter(r=>!e.includes(r));if(s.length===0)return;console.log(`Rescanning vault for newly excluded patterns: ${s.join(", ")}`),new n.Notice(`Finding files to delete for: ${s.join(", ")}`);let o=this.app.vault.getFiles(),a=0;for(let r of o)for(let l of s){if(!l.trim())continue;let d=!1;if(l.endsWith("/"))(r.path.startsWith(l)||r.path.includes("/"+l))&&(d=!0);else if(l.includes("*")){let h=l.replace(/\./g,"\\.").replace(/\*\*/g,".*").replace(/\*/g,"[^/]*");new RegExp("^"+h+"$").test(r.path)&&(d=!0)}else((r.path.split("/").pop()||"")===l||r.path===l||r.path.endsWith("/"+l))&&(d=!0);if(d){this.pendingUploads.delete(r.path),this.pendingDeletes.add(r.path),a++;break}}a>0?(console.log(`Queued ${a} files for deletion`),new n.Notice(`Queued ${a} files for deletion from server`),this.updateStatusBar("pending")):new n.Notice("No matching files found to delete")}startSyncInterval(){this.stopSyncInterval();let e=this.settings.syncIntervalMinutes*60*1e3;this.syncIntervalId=window.setInterval(()=>this.processQueue(),e),console.log(`Sync interval started: every ${this.settings.syncIntervalMinutes} minute(s)`)}stopSyncInterval(){this.syncIntervalId!==null&&(window.clearInterval(this.syncIntervalId),this.syncIntervalId=null)}restartSyncInterval(){this.startSyncInterval()}updateStatusBar(e,t){let o=`${{idle:"\u{1F52E}",pending:"\u{1F550}",syncing:"\u{1F504}",success:"\u2705",error:"\u274C"}[e]} Knosi`;e==="pending"&&this.pendingUploads.size>0?o+=` (${this.pendingUploads.size})`:t&&(o+=`: ${t}`),this.statusBarItem.setText(o)}isSupportedFile(e){if(!(e instanceof n.TFile))return!1;let t="."+e.extension.toLowerCase();return this.settings.supportedExtensions.includes(t)}isExcluded(e){for(let t of this.settings.excludePatterns)if(t.trim()){if(t.endsWith("/")){if(e.startsWith(t)||e.includes("/"+t))return!0}else if(t.includes("*")){let s=t.replace(/\./g,"\\.").replace(/\*\*/g,".*").replace(/\*/g,"[^/]*");if(new RegExp("^"+s+"$").test(e))return!0}else if((e.split("/").pop()||"")===t||e===t||e.endsWith("/"+t))return!0}return!1}queueFileUpload(e){if(this.isSupportedFile(e)){if(this.isExcluded(e.path)){console.log(`Skipping excluded file: ${e.path}`);return}this.pendingDeletes.delete(e.path),this.pendingUploads.add(e.path),this.updateStatusBar("pending"),console.log(`Queued for sync: ${e.path} (${this.pendingUploads.size} in queue)`)}}queueFileDelete(e){if(!(e instanceof n.TFile))return;let t="."+e.extension.toLowerCase();this.settings.supportedExtensions.includes(t)&&(this.pendingUploads.delete(e.path),this.pendingDeletes.add(e.path),this.updateStatusBar("pending"),console.log(`Queued for delete: ${e.path}`))}handleFileRename(e,t){this.isSupportedFile(e)&&(this.pendingDeletes.add(t),this.pendingUploads.delete(t),this.pendingUploads.add(e.path),this.pendingDeletes.delete(e.path),this.updateStatusBar("pending"))}async processQueue(){if(this.syncInProgress){console.log("Sync already in progress, skipping");return}let e=new Set(this.pendingUploads),t=new Set(this.pendingDeletes);if(e.size===0&&t.size===0)return;this.syncInProgress=!0,this.updateStatusBar("syncing",`${e.size} files`),console.log(`Processing queue: ${e.size} uploads, ${t.size} deletes`);let s=0,o=0,a=0;for(let r of t)try{await this.deleteFileByPath(r),this.pendingDeletes.delete(r),o++}catch(l){a++}for(let r of e){let l=this.app.vault.getAbstractFileByPath(r);if(l instanceof n.TFile)try{await this.uploadFile(l),this.pendingUploads.delete(r),s++}catch(d){a++}else this.pendingUploads.delete(r)}this.syncInProgress=!1,a>0?(this.updateStatusBar("error",`${a} failed`),setTimeout(()=>this.updateStatusBar("idle"),5e3)):s>0||o>0?(this.updateStatusBar("success"),setTimeout(()=>{this.pendingUploads.size>0?this.updateStatusBar("pending"):this.updateStatusBar("idle")},2e3)):this.updateStatusBar("idle"),console.log(`Queue processed: ${s} uploaded, ${o} deleted, ${a} errors`)}viewQueue(){let e=Array.from(this.pendingUploads),t=Array.from(this.pendingDeletes);if(e.length===0&&t.length===0){new n.Notice("Sync queue is empty");return}let s="";e.length>0&&(s+=`\u{1F4E4} Pending uploads (${e.length}):
${e.slice(0,10).join(`
`)}`,e.length>10&&(s+=`
...and ${e.length-10} more`)),t.length>0&&(s&&(s+=`

`),s+=`\u{1F5D1}\uFE0F Pending deletes (${t.length}):
${t.slice(0,10).join(`
`)}`,t.length>10&&(s+=`
...and ${t.length-10} more`)),new n.Notice(s,1e4)}async uploadFile(e){try{let t=await this.app.vault.readBinary(e);if(t.byteLength===0){console.log(`Skipping empty file: ${e.path}`);return}let s=new Blob([t]),o=new FormData;o.append("file",s,e.name),o.append("path",e.path);let a=await fetch(`${this.settings.serverUrl}/api/upload`,{method:"POST",headers:{"X-API-Key":this.settings.apiKey},body:o});if(!a.ok){let l=await a.json();throw new Error(l.detail||`HTTP ${a.status}`)}let r=await a.json();this.settings.verboseLogging&&console.log(`Synced: ${e.path} (${r.status})`)}catch(t){throw console.error(`Failed to sync ${e.path}:`,t),t}}async deleteFileByPath(e){try{(await fetch(`${this.settings.serverUrl}/api/documents/${encodeURIComponent(e)}`,{method:"DELETE",headers:{"X-API-Key":this.settings.apiKey}})).ok&&this.settings.verboseLogging&&console.log(`Deleted from index: ${e}`)}catch(t){throw console.error(`Failed to delete ${e}:`,t),t}}async syncCurrentFile(){let e=this.app.workspace.getActiveFile();if(!e){new n.Notice("No file is currently open");return}if(!this.isSupportedFile(e)){new n.Notice(`File type .${e.extension} is not supported`);return}this.updateStatusBar("syncing",e.name);try{await this.uploadFile(e),this.updateStatusBar("success"),new n.Notice(`Synced: ${e.name}`)}catch(t){this.updateStatusBar("error",e.name),new n.Notice(`Failed to sync: ${t.message}`)}setTimeout(()=>this.updateStatusBar("idle"),2e3)}async syncAllFiles(){if(this.syncInProgress){new n.Notice("Sync already in progress");return}this.syncInProgress=!0,this.updateStatusBar("syncing","all files");let e=this.app.vault.getFiles().filter(o=>this.isSupportedFile(o)),t=0,s=0;new n.Notice(`Syncing ${e.length} files...`);for(let o of e)try{await this.uploadFile(o),t++}catch(a){s++}this.syncInProgress=!1,this.updateStatusBar("idle"),new n.Notice(`Sync complete: ${t} files synced${s>0?`, ${s} errors`:""}`)}async checkServerStatus(){try{let e=await fetch(`${this.settings.serverUrl}/api/status`,{headers:{"X-API-Key":this.settings.apiKey}});if(!e.ok){e.status===401?new n.Notice("\u274C Authentication failed - check API key"):new n.Notice(`\u274C Server error: ${e.status}`);return}let t=await e.json();new n.Notice(`\u2705 Connected: ${t.document_count} documents, ${t.chunk_count} chunks`)}catch(e){new n.Notice(`\u274C Cannot connect to server: ${e.message}`)}}},g=class extends n.PluginSettingTab{constructor(i,e){super(i,e),this.plugin=e}display(){let{containerEl:i}=this;i.empty(),this.originalSettings=JSON.parse(JSON.stringify(this.plugin.settings)),this.tempSettings=JSON.parse(JSON.stringify(this.plugin.settings)),i.createEl("h1",{text:"Knosi"}),new n.Setting(i).setName("Server URL").setDesc("URL of your Knosi API server").addText(e=>e.setPlaceholder("http://localhost:48550").setValue(this.tempSettings.serverUrl).onChange(t=>{this.tempSettings.serverUrl=t})),new n.Setting(i).setName("API Key").setDesc("API key for authentication (if required)").addText(e=>{e.setPlaceholder("Enter API key").setValue(this.tempSettings.apiKey).onChange(t=>{this.tempSettings.apiKey=t}),e.inputEl.type="password"}),new n.Setting(i).setName("Auto-sync").setDesc("Automatically queue files for sync when created or modified (requires Obsidian restart)").addToggle(e=>e.setValue(this.tempSettings.autoSync).onChange(t=>{this.tempSettings.autoSync=t})),new n.Setting(i).setName("Sync interval (minutes)").setDesc("How often to process the sync queue. Lower = more frequent syncs, higher = fewer API calls.").addSlider(e=>e.setLimits(1,60,1).setValue(this.tempSettings.syncIntervalMinutes).setDynamicTooltip().onChange(t=>{this.tempSettings.syncIntervalMinutes=t})).addExtraButton(e=>e.setIcon("reset").setTooltip("Reset to default (1 minute)").onClick(()=>{this.tempSettings.syncIntervalMinutes=1,this.display()})),new n.Setting(i).setName("Sync on startup").setDesc("Sync all files when Obsidian opens").addToggle(e=>e.setValue(this.tempSettings.syncOnStartup).onChange(t=>{this.tempSettings.syncOnStartup=t})),new n.Setting(i).setName("Supported extensions").setDesc("File extensions to sync (comma-separated). Changes will trigger a rescan when saved.").addText(e=>e.setPlaceholder(".md, .txt, .pdf").setValue(this.tempSettings.supportedExtensions.join(", ")).onChange(t=>{this.tempSettings.supportedExtensions=t.split(",").map(s=>s.trim().toLowerCase()).filter(s=>s.startsWith("."))})),new n.Setting(i).setName("Verbose logging").setDesc("Log all sync operations to console. When disabled, only errors are logged.").addToggle(e=>e.setValue(this.tempSettings.verboseLogging).onChange(t=>{this.tempSettings.verboseLogging=t})),new n.Setting(i).setName("Exclude patterns").setDesc("Paths/files to exclude (comma-separated). Supports directories (end with /), filenames, or glob patterns (*). Adding new patterns will delete matching files from server when saved.").addTextArea(e=>{e.setPlaceholder(".obsidian/, Templates/, *.tmp, **/*.backup").setValue(this.tempSettings.excludePatterns.join(", ")).onChange(t=>{this.tempSettings.excludePatterns=t.split(",").map(s=>s.trim()).filter(s=>s.length>0)}),e.inputEl.rows=3,e.inputEl.style.width="100%"}),new n.Setting(i).addButton(e=>e.setButtonText("Save").setCta().onClick(async()=>{await this.saveSettings()})),i.createEl("h3",{text:"Actions"}),new n.Setting(i).setName("Test connection").setDesc("Check if the server is reachable").addButton(e=>e.setButtonText("Test").onClick(()=>this.plugin.checkServerStatus())),new n.Setting(i).setName("View sync queue").setDesc("Show files pending sync").addButton(e=>e.setButtonText("View Queue").onClick(()=>this.plugin.viewQueue())),new n.Setting(i).setName("Process queue now").setDesc("Sync all pending files immediately").addButton(e=>e.setButtonText("Sync Now").onClick(()=>this.plugin.processQueue())),new n.Setting(i).setName("Sync all files").setDesc("Upload all supported files to the server (bypasses queue)").addButton(e=>e.setButtonText("Sync All").setCta().onClick(()=>this.plugin.syncAllFiles()))}async saveSettings(){let i=JSON.stringify(this.originalSettings.supportedExtensions)!==JSON.stringify(this.tempSettings.supportedExtensions),e=JSON.stringify(this.originalSettings.excludePatterns)!==JSON.stringify(this.tempSettings.excludePatterns),t=this.originalSettings.syncIntervalMinutes!==this.tempSettings.syncIntervalMinutes,s=this.originalSettings.autoSync!==this.tempSettings.autoSync;if(this.plugin.settings=JSON.parse(JSON.stringify(this.tempSettings)),await this.plugin.saveData(this.plugin.settings),t&&this.plugin.restartSyncInterval(),s&&new n.Notice("Restart Obsidian for auto-sync changes to take effect"),i){let o=this.originalSettings.supportedExtensions,a=this.tempSettings.supportedExtensions;this.plugin.rescanVaultForNewExtensions(o,a)}if(e){let o=this.originalSettings.excludePatterns,a=this.tempSettings.excludePatterns;this.plugin.rescanVaultForNewExclusions(o,a)}new n.Notice("Settings saved"),this.originalSettings=JSON.parse(JSON.stringify(this.tempSettings))}};
